
<!DOCTYPE html>
<html lang="null">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Vincent’s Zone">
    <title>Archives: 2016/7 - Vincent’s Zone</title>
    <meta name="author" content="Vincent">
    
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta name="description" content="不积跬步,无以至千里;不积小流,无以成江海">
<meta property="og:type" content="blog">
<meta property="og:title" content="Vincent’s Zone">
<meta property="og:url" content="http://yoursite.com/archives/2016/07/index.html">
<meta property="og:site_name" content="Vincent’s Zone">
<meta property="og:description" content="不积跬步,无以至千里;不积小流,无以成江海">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Vincent’s Zone">
<meta name="twitter:description" content="不积跬步,无以至千里;不积小流,无以成江海">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-sostf8a1aivpmdlygot3rltry8aweydwovdzyxr97qzr9cf2eciqkhffzoth.min.css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <h1 class="header-title">
        <a class="header-title-link" href="/ ">Vincent’s Zone</a>
    </h1>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link open-algolia-search"
                             href="#search"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-search"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/atom.xml"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/07/28/Rxjava入门/">
                            Rxjava学习总结
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-07-28T00:00:00+08:00">
	
		    Jul 28, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Rx/">Rx</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p>参考：<br><a href="https://gank.io/post/560e15be2dca930e00da1083#toc_19" target="_blank" rel="external">给 Android 开发者的 RxJava 详解-扔物线</a><br><a href="http://blog.csdn.net/lzyzsd/article/details/41833541" target="_blank" rel="external">深入浅出RxJava</a></p>
<p>##基础<br>“a library for composing asynchronous and event-based programs using observable sequences for the Java VM” （一个在 Java VM 上使用可观测的序列来组成==异步==的、基于事件的程序的库）</p>
<p>采用函数响应式编程的思想，使异步代码更简洁、逻辑更清晰，避免了令人头痛的回调的嵌套、线程调度等问题。</p>
<p>###RxJava 的观察者模式<br>RxJava 有四个基本概念：Observable (被观察者)、 Subscriber (观察者)、 subscribe (订阅)、事件。</p>
<p>Observable 和 Subscriber 通过 subscribe() 方法实现订阅关系，从而 Observable 可以在需要的时候发出事件来通知 Subscriber。</p>
<p>与传统观察者模式的区别是：</p>
<ul>
<li>如果 Observerble 没有任何的 Subscriber，那么这个 Observable 不会发出任何事件的。</li>
<li>RxJava 的事件回调方法除了普通事件 onNext() （相当于 onClick() / onEvent()）之外，还定义了两个特殊的事件：onCompleted() 和 onError()。<br><img src="/Users/dengfa/MyZone/macDown/img/52eb2279jw1f2rx46dspqj20gn04qaad.jpg" alt=""></li>
<li>onCompleted(): 事件队列完结。当事件流发送完毕时，会触发 onCompleted() 方法。</li>
<li>onError(): 事件队列异常。在事件处理过程中有异常抛出时，onError() 会被触发，同时队列自动终止，不允许再有事件发出。(RxJava 不仅把每个事件单独处理，还会把它们看做一个队列。)</li>
</ul>
<p>##基本实现</p>
<p>###1.创建Observable<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Observable observable = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</div><div class="line">        subscriber.onNext(<span class="string">"Hello"</span>);</div><div class="line">        subscriber.onNext(<span class="string">"Hi"</span>);</div><div class="line">        subscriber.onNext(<span class="string">"Aloha"</span>);</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>Observable 即被观察者，它决定什么时候触发事件以及触发怎样的事件。<br>这里，使用<code>create()</code>方法来创建一个 Observable，并定义事件触发规则：观察者Subscriber 将会被调用三次 <code>onNext()</code> 和一次 <code>onCompleted()</code>。这里传入了一个 OnSubscribe 对象作为参数。OnSubscribe 会被存储在返回的 Observable 对象中，它的作用相当于一个计划表，当 Observable 被订阅的时候，OnSubscribe 的 <code>call()</code> 方法会自动被调用，事件序列就会依照设定依次触发。这样，由被观察者调用了观察者的回调方法，就实现了由被观察者向观察者的事件传递，即观察者模式。</p>
<p><code>create()</code>方法是 RxJava 最基本的创造事件序列的方法。基于这个方法， RxJava 还提供了一些方法用来快捷创建事件队列，例如：</p>
<ul>
<li><code>just(T...)</code>: 将传入的参数依次发送出来。</li>
<li><code>from(T[]) / from(Iterable&lt;? extends T&gt;)</code> : 将传入的数组或 Iterable 拆分成具体对象后，依次发送出来。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable observable = Observable.just(<span class="string">"Hello"</span>, <span class="string">"Hi"</span>, <span class="string">"Aloha"</span>);</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String[] words = &#123;<span class="string">"Hello"</span>, <span class="string">"Hi"</span>, <span class="string">"Aloha"</span>&#125;;</div><div class="line">Observable observable = Observable.from(words);</div></pre></td></tr></table></figure>
<p>这两段代码与前面的创建方式等价。</p>
<p>###2.创建Observer<br>Observer 即观察者，它决定事件触发的时候将有怎样的行为。<br>RxJava 中的 Observer 接口： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此外，RxJava 还内置了一个实现了 Observer、Subscription 的抽象类：Subscriber。<br>Subscriber 对 Observer 接口进行了一些扩展： </p>
<ol>
<li><code>onStart()</code>: 在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行），<code>onStart()</code>就不适用了，因为它总是在 subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用<code>doOnSubscribe()</code>方法。</li>
<li><code>unsubscribe()</code>: 这是 Subscriber 所实现的另一个接口 Subscription 的方法，用于取消订阅。在这个方法被调用后，Subscriber 将不再接收事件。一般在这个方法调用前，可以使用<code>isUnsubscribed()</code>先判断一下状态。<code>unsubscribe()</code>这个方法很重要，因为在 <code>subscribe()</code>之后， Observable 会持有 Subscriber 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如<code>onPause()``onStop()</code>等方法中）调用 unsubscribe() 来解除引用关系，以避免内存泄露的发生。</li>
</ol>
<p>###3.Subscribe<br>通过subscribe()方法将被观察者和观察者关联起来： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">observable.subscribe(subscriber);</div></pre></td></tr></table></figure>
<p>内部实现（仅核心代码）： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Subscription <span class="title">subscribe</span><span class="params">(Subscriber subscriber)</span> </span>&#123;</div><div class="line">    subscriber.onStart();</div><div class="line">    onSubscribe.call(subscriber);</div><div class="line">    <span class="keyword">return</span> subscriber;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>subscriber()</code>主要做了3件事： </p>
<ol>
<li>调用<code>Subscriber.onStart()</code>，进行订阅前的初始化工作。</li>
<li>调用 Observable 中的 <code>OnSubscribe.call(Subscriber)</code>。事件发送的逻辑开始运行。可以看到， Observable 并不是在创建的时候就立即开始发送事件，而是在它被订阅的时候，即当<code>subscribe()</code>方法执行的时候，才开始发送事件。</li>
<li>将传入的 Subscriber 作为 Subscription 返回，便于解除订阅<code>unsubscribe()</code>.<br><img src="/Users/dengfa/MyZone/macDown/img/52eb2279jw1f2rx4ay0hrg20ig08wk4q.gif" alt=""></li>
</ol>
<p>##线程控制</p>
<p>默认情况下，事件的发出和 消费都是在同一个线程的。<br>要实现『后台处理，前台回调』的异步机制，可以使用<code>subscribeOn()</code>和<code>observeOn()</code>两个方法，结合Scheduler，来对线程进行控制。 </p>
<ul>
<li><code>subscribeOn()</code>: 指定<code>subscribe()</code>所发生的线程，即<code>Observable.OnSubscribe</code>被激活时所处的线程。或者叫做事件产生的线程。 </li>
<li><code>observeOn()</code>: 指定 Subscriber 所运行的线程。或者叫做事件消费的线程。</li>
</ul>
<p>RxJava 内置的 Scheduler： </p>
<ul>
<li><code>Schedulers.immediate()</code>: 直接在当前线程运行，这是默认的 Scheduler。</li>
<li><code>Schedulers.newThread()</code>: 总是启用新线程，并在新线程执行操作。</li>
<li><code>Schedulers.io()</code>: I/O 操作（读写文件、读写数据库、网络信息交互等）。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是使用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。注意不要把计算工作放在 io() 线程中，以避免创建不必要的线程。</li>
<li><code>Schedulers.computation()</code>: 用于 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用固定的线程池，大小为 CPU 核数。注意不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。</li>
<li><code>AndroidSchedulers.mainThread()</code>：Android 主线程。</li>
</ul>
<p>示例（适用于多数的 『后台线程取数据，主线程显示』的程序策略）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line">    .subscribeOn(Schedulers.io()) <span class="comment">// 指定 subscribe() 发生在 IO 线程</span></div><div class="line">    .observeOn(AndroidSchedulers.mainThread()) <span class="comment">// 指定 Subscriber 的回调发生在主线程</span></div><div class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;Integer&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Integer number)</span> </span>&#123;</div><div class="line">            Log.d(tag, <span class="string">"number:"</span> + number);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p><strong>线程的自用控制：</strong><br>observeOn() 指定的是 Subscriber 的线程，而这个 Subscriber 并不一定是subscribe() 参数中的 Subscriber ，而是 observeOn() 执行时的当前 Observable 所对应的Subscriber ，即它的直接下级 Subscriber 。换句话说，observeOn() 指定的是它之后的操作所在的线程。因此如果有多次切换线程的需求，只要在每个想要切换线程的位置调用一次 observeOn() 即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// IO 线程，由 subscribeOn() 指定</span></div><div class="line">    .subscribeOn(Schedulers.io())</div><div class="line">    .observeOn(Schedulers.newThread())</div><div class="line">    .map(mapOperator) <span class="comment">// 新线程，由 observeOn() 指定</span></div><div class="line">    .observeOn(Schedulers.io())</div><div class="line">    .map(mapOperator2) <span class="comment">// IO 线程，由 observeOn() 指定</span></div><div class="line">    .observeOn(AndroidSchedulers.mainThread) </div><div class="line">    .subscribe(subscriber);  <span class="comment">// Android 主线程，由 observeOn() 指定</span></div></pre></td></tr></table></figure>
<p>subscribeOn() 和 observeOn() 的内部实现，也是基于 lift() 方法。<br>subscribeOn() 原理图：<br><img src="/Users/dengfa/MyZone/我的博客/img/52eb2279jw1f2rxcynbsuj20ha0d7wg2.jpg" alt=""><br>observeOn() 原理图：<br><img src="/Users/dengfa/MyZone/我的博客/img/52eb2279jw1f2rxd05lttj20hj0cyabl.jpg" alt=""></p>
<p>从图中可以看出，subscribeOn() 和 observeOn() 都做了线程切换的工作（图中的 “schedule…” 部位）。不同的是， subscribeOn() 的线程切换发生在 OnSubscribe 中，即在它通知上一级 OnSubscribe 时，这时事件还没有开始发送，因此 subscribeOn() 的线程控制可以从事件发出的开端就造成影响；而 observeOn() 的线程切换则发生在它内建的 Subscriber 中，即发生在它即将给下一级 Subscriber 发送事件时，因此 observeOn() 控制的是它后面的线程。</p>
<p>多个 subscribeOn() 和 observeOn() 混合使用时，线程调度的流程图：<br><img src="/Users/dengfa/MyZone/我的博客/img/52eb2279jw1f2rxd1vl7xj20hd0hzq6e.jpg" alt=""><br>图中共有 5 处含有对事件的操作。由图中可以看出，①和②两处受第一个 subscribeOn() 影响，运行在红色线程；③和④处受第一个 observeOn() 的影响，运行在绿色线程；⑤处受第二个 onserveOn() 影响，运行在紫色线程；而第二个 subscribeOn() ，由于在通知过程中线程就被第一个 subscribeOn() 截断，因此对整个流程并没有任何影响。这里也就回答了前面的问题：==当使用了多个 subscribeOn() 的时候，只有第一个 subscribeOn() 起作用。==</p>
<p>##事件变换<br>RxJava 提供了对事件序列进行变换的支持，这是它的核心功能之一，将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。</p>
<p>###lift:针对事件项和事件序列的变换<br><code>map()</code>、<code>flatMap()</code>等变换都是基于同一个基础的变换方法<code>lift(Operator)</code>的包装。 </p>
<p><code>lift()</code>的内部实现（仅核心代码）： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">lift</span><span class="params">(Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> OnSubscribe&lt;R&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber subscriber)</span> </span>&#123;</div><div class="line">            Subscriber newSubscriber = operator.call(subscriber);</div><div class="line">            newSubscriber.onStart();</div><div class="line">            onSubscribe.call(newSubscriber);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1.lift() 创建了一个 Observable 后，加上之前的原始 Observable，已经有两个 Observable 了；<br>2.而同样地，新 Observable 里的新 OnSubscribe 加上之前的原始 Observable 中的原始 OnSubscribe，也就有了两个 OnSubscribe；<br>3.当用户调用经过 lift() 后的 Observable 的 subscribe() 的时候，使用的是 lift() 所返回的新的 Observable ，于是它所触发的 onSubscribe.call(subscriber)，也是用的新 Observable 中的新 OnSubscribe，即在 lift() 中生成的那个 OnSubscribe；<br>4.而这个新 OnSubscribe 的 call() 方法中的 onSubscribe ，就是指的原始 Observable 中的原始 OnSubscribe ，在这个 call() 方法里，新 OnSubscribe 利用 operator.call(subscriber) 生成了一个新的 Subscriber（Operator 就是在这里，通过自己的 call() 方法将新 Subscriber 和原始 Subscriber 进行关联，并插入自己的『变换』代码以实现变换），然后利用这个新 Subscriber 向原始 Observable 进行订阅。<br>这样就实现了 lift() 过程，有点像一种代理机制，通过事件拦截和处理实现事件序列的变换。</p>
<p>简而言之，在 Observable 执行了 lift(Operator) 方法之后，会返回一个新的 Observable，这个新的 Observable 会像一个代理一样，负责接收原始的 Observable 发出的事件，并在处理后发送给 Subscriber。<br><img src="/Users/dengfa/MyZone/我的博客/img/52eb2279jw1f2rxcu9f46g20go0cz4qp.gif" alt=""><br>两次和多次的 lift() 同理：<br><img src="/Users/dengfa/MyZone/我的博客/img/52eb2279jw1f2rxcvophmj20h30hl0v3.jpg" alt=""></p>
<p>示例：将事件中的 Integer 对象转换成 String</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">observable.lift(<span class="keyword">new</span> Observable.Operator&lt;String, Integer&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Subscriber&lt;? <span class="keyword">super</span> Integer&gt; call(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber) &#123;</div><div class="line">        <span class="comment">// 将事件序列中的 Integer 对象转换为 String 对象</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">                subscriber.onNext(<span class="string">""</span> + integer);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">                subscriber.onCompleted();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">                subscriber.onError(e);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>###compose: 对 Observable 整体的变换<br>它和 lift() 的区别在于， lift() 是针对事件项和事件序列的，而 compose() 是针对 Observable 自身进行变换。 </p>
<p>示例：<br>假设在程序中有多个 Observable ，并且他们都需要应用一组相同的 lift() 变换。你可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">observable1</div><div class="line">    .lift1()</div><div class="line">    .lift2()</div><div class="line">    .lift3()</div><div class="line">    .lift4()</div><div class="line">    .subscribe(subscriber1);</div><div class="line">observable2</div><div class="line">    .lift1()</div><div class="line">    .lift2()</div><div class="line">    .lift3()</div><div class="line">    .lift4()</div><div class="line">    .subscribe(subscriber2);</div><div class="line">observable3</div><div class="line">    .lift1()</div><div class="line">    .lift2()</div><div class="line">    .lift3()</div><div class="line">    .lift4()</div><div class="line">    .subscribe(subscriber3);</div><div class="line">observable4</div><div class="line">    .lift1()</div><div class="line">    .lift2()</div><div class="line">    .lift3()</div><div class="line">    .lift4()</div><div class="line">    .subscribe(subscriber1);</div></pre></td></tr></table></figure>
<p>这样代码复用性太差，于是改写成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Observable <span class="title">liftAll</span><span class="params">(Observable observable)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> observable</div><div class="line">        .lift1()</div><div class="line">        .lift2()</div><div class="line">        .lift3()</div><div class="line">        .lift4();</div><div class="line">&#125;</div><div class="line">...</div><div class="line">liftAll(observable1).subscribe(subscriber1);</div><div class="line">liftAll(observable2).subscribe(subscriber2);</div><div class="line">liftAll(observable3).subscribe(subscriber3);</div><div class="line">liftAll(observable4).subscribe(subscriber4);</div></pre></td></tr></table></figure>
<p>可读性、可维护性都提高了。可是 Observable 被一个方法包起来，如果后期需求变化，observable1在进行liftAll()变换前需要先进行lift5()变换，就打破了api的链式调用，这种方式对于 Observale 的灵活性增添了限制。此时，就可以用 compose() 来解决：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiftAllTransformer</span> <span class="keyword">implements</span> <span class="title">Observable</span>.<span class="title">Transformer</span>&lt;<span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">call</span><span class="params">(Observable&lt;Integer&gt; observable)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> observable</div><div class="line">            .lift1()</div><div class="line">            .lift2()</div><div class="line">            .lift3()</div><div class="line">            .lift4();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">...</div><div class="line">Transformer liftAll = <span class="keyword">new</span> LiftAllTransformer();</div><div class="line">observable1.compose(liftAll).subscribe(subscriber1);</div><div class="line">observable2.compose(liftAll).subscribe(subscriber2);</div><div class="line">observable3.compose(liftAll).subscribe(subscriber3);</div><div class="line">observable4.compose(liftAll).subscribe(subscriber4);</div></pre></td></tr></table></figure>
<p>##操作符<br><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Operators.html" target="_blank" rel="external">Rx中文文档</a><br><a href="http://wiki.jikexueyuan.com/project/rxjava//chapter4/filtering_a_sequence.html" target="_blank" rel="external">操作符的使用示例</a></p>
<p>###创建操作</p>
<ul>
<li>Create — 通过调用观察者的方法从头创建一个Observable</li>
<li>Defer — 在观察者订阅之前不创建这个Observable，为每一个观察者创建一个新的Observable</li>
<li>Empty/Never/Throw — 创建行为受限的特殊Observable</li>
<li>From — 将其它的对象或数据结构转换为Observable</li>
<li>Interval — 创建一个定时发射整数序列的Observable</li>
<li>Just — 将对象或者对象集合转换为一个会发射这些对象的Observable</li>
<li>Range — 创建发射指定范围的整数序列的Observable</li>
<li>Repeat — 创建重复发射特定的数据或数据序列的Observable</li>
<li>Start — 创建发射一个函数的返回值的Observable</li>
<li>Timer — 创建在一个指定的延迟之后发射单个数据的Observable</li>
</ul>
<p>###变换操作</p>
<ul>
<li>Buffer — 缓存，可以简单的理解为缓存，它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个</li>
<li>FlatMap — 扁平映射，将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，可以认为是一个将嵌套的数据结构展开的过程。</li>
<li>GroupBy — 分组，将原来的Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据</li>
<li>Map — 映射，通过对序列的每一项都应用一个函数变换Observable发射的数据，实质是对序列中的每一项执行一个函数，函数的参数就是这个数据项</li>
<li>Scan — 扫描，对Observable发射的每一项数据应用一个函数，然后按顺序依次发射这些值</li>
<li>Window — 窗口，定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。类似于Buffer，但Buffer发射的是数据，Window发射的是Observable，每一个Observable发射原始Observable的数据的一个子集</li>
</ul>
<p>###过滤操作</p>
<ul>
<li>Debounce — 只有在空闲了一段时间后才发射数据，通俗的说，就是如果一段时间没有操作，就执行一次操作</li>
<li>Distinct — 去重，过滤掉重复数据项</li>
<li>ElementAt — 取值，取特定位置的数据项</li>
<li>Filter — 过滤，过滤掉没有通过谓词测试的数据项，只发射通过测试的</li>
<li>First — 首项，只发射满足条件的第一条数据</li>
<li>IgnoreElements — 忽略所有的数据，只保留终止通知(onError或onCompleted)</li>
<li>Last — 末项，只发射最后一条数据</li>
<li>Sample — 取样，定期发射最新的数据，等于是数据抽样，有的实现里叫ThrottleFirst</li>
<li>Skip — 跳过前面的若干项数据</li>
<li>SkipLast — 跳过后面的若干项数据</li>
<li>Take — 只保留前面的若干项数据</li>
<li>TakeLast — 只保留后面的若干项数据</li>
</ul>
<p>###组合操作</p>
<ul>
<li>And/Then/When — 通过模式(And条件)和计划(Then次序)组合两个或多个Observable发射的数据集</li>
<li>CombineLatest — 当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果</li>
<li>Join — 无论何时，如果一个Observable发射了一个数据项，只要在另一个Observable发射的数据项定义的时间窗口内，就将两个Observable发射的数据合并发射</li>
<li>Merge — 将两个Observable发射的数据组合并成一个</li>
<li>StartWith — 在发射原来的Observable的数据序列之前，先发射一个指定的数据序列或数据项</li>
<li>Switch — 将一个发射Observable序列的Observable转换为这样一个Observable：它逐个发射那些Observable最近发射的数据</li>
<li>Zip — 打包，使用一个指定的函数将多个Observable发射的数据组合在一起，然后将这个函数的结果作为单项数据发射</li>
</ul>
<p>###错误处理<br>这些操作符用于从错误通知中恢复：</p>
<ul>
<li>Catch — 捕获，继续序列操作，将错误替换为正常的数据，从onError通知中恢复</li>
<li>Retry — 重试，如果Observable发射了一个错误通知，重新订阅它，期待它正常终止 </li>
</ul>
<p>###辅助操作</p>
<ul>
<li>Delay — 延迟一段时间发射结果数据</li>
<li>Do — 注册一个动作占用一些Observable的生命周期事件，相当于Mock某个操作</li>
<li>Materialize/Dematerialize — 将发射的数据和通知都当做数据发射，或者反过来</li>
<li>ObserveOn — 指定观察者观察Observable的调度程序（工作线程）</li>
<li>Serialize — 强制Observable按次序发射数据并且功能是有效的</li>
<li>Subscribe — 收到Observable发射的数据和通知后执行的操作</li>
<li>SubscribeOn — 指定Observable应该在哪个调度程序上执行</li>
<li>TimeInterval — 将一个Observable转换为发射两个数据之间所耗费时间的Observable</li>
<li>Timeout — 添加超时机制，如果过了指定的一段时间没有发射数据，就发射一个错误通知</li>
<li>Timestamp — 给Observable发射的每个数据项添加一个时间戳</li>
<li>Using — 创建一个只在Observable的生命周期内存在的一次性资源</li>
</ul>
<p>###条件和布尔操作<br>这些操作符可用于单个或多个数据项，也可用于Observable。</p>
<ul>
<li>All — 判断Observable发射的所有的数据项是否都满足某个条件</li>
<li>Amb — 给定多个Observable，只让第一个发射数据的Observable发射全部数据</li>
<li>Contains — 判断Observable是否会发射一个指定的数据项</li>
<li>DefaultIfEmpty — 发射来自原始Observable的数据，如果原始Observable没有发射数据，就发射一个默认数据</li>
<li>SequenceEqual — 判断两个Observable是否按相同的数据序列</li>
<li>SkipUntil — 丢弃原始Observable发射的数据，直到第二个Observable发射了一个数据，然后发射原始Observable的剩余数据</li>
<li>SkipWhile — 丢弃原始Observable发射的数据，直到一个特定的条件为假，然后发射原始Observable剩余的数据</li>
<li>TakeUntil — 发射来自原始Observable的数据，直到第二个Observable发射了一个数据或一个通知</li>
<li>TakeWhile — 发射原始Observable的数据，直到一个特定的条件为真，然后跳过剩余的数据</li>
</ul>
<p>###算术和聚合操作<br>这些操作符可用于整个数据序列</p>
<ul>
<li>Average — 计算Observable发射的数据序列的平均值，然后发射这个结果</li>
<li>Concat — 不交错的连接多个Observable的数据</li>
<li>Count — 计算Observable发射的数据个数，然后发射这个结果</li>
<li>Max — 计算并发射数据序列的最大值</li>
<li>Min — 计算并发射数据序列的最小值</li>
<li>Reduce — 按顺序对数据序列的每一个应用某个函数，然后返回这个值</li>
<li>Sum — 计算并发射数据序列的和</li>
</ul>
<p>###连接操作<br>一些有精确可控的订阅行为的特殊Observable</p>
<ul>
<li>Connect — 指示一个可连接的Observable开始发射数据给订阅者</li>
<li>Publish — 将一个普通的Observable转换为可连接的</li>
<li>RefCount — 使一个可连接的Observable表现得像一个普通的Observable</li>
<li>Replay — 确保所有的观察者收到同样的数据序列，即使他们在Observable开始发射数据之后才订阅</li>
</ul>
<p>###转换操作</p>
<ul>
<li>To — 将Observable转换为其它的对象或数据结构</li>
<li>Blocking - 阻塞Observable的操作符</li>
</ul>
<p>##使用场景</p>
<ul>
<li>与 Retrofit 的结合</li>
<li>RxBinding</li>
<li>各种异步操作</li>
<li>RxBus</li>
</ul>
<p>##其他</p>
<p>###subscribe()不完整定义的回调，Action、Function接口</p>
<p>###doOnSubscribe()<br>Subscriber 的 onStart() 可以用作流程开始前的初始化。然而 onStart() 由于在 subscribe() 发生时就被调用了，因此不能指定线程，而是只能执行在 subscribe() 被调用时的线程。这就导致如果 onStart() 中含有对线程有要求的代码（例如在界面上显示一个 ProgressBar，这必须在主线程执行），将会有线程非法的风险，因为有时你无法预测 subscribe() 将会在什么线程执行。</p>
<p>而与 Subscriber.onStart() 相对应的，有一个方法 Observable.doOnSubscribe() 。它和 Subscriber.onStart() 同样是在 subscribe() 调用后而且在事件发送前执行，但区别在于它可以指定线程。默认情况下， doOnSubscribe() 执行在 subscribe() 发生的线程；而如果在 doOnSubscribe() 之后有 subscribeOn() 的话，它将执行在离它最近的 subscribeOn() 所指定的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Observable.create(onSubscribe)</div><div class="line">    .subscribeOn(Schedulers.io())</div><div class="line">    .doOnSubscribe(<span class="keyword">new</span> Action0() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">            progressBar.setVisibility(View.VISIBLE); <span class="comment">// 需要在主线程执行</span></div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    .subscribeOn(AndroidSchedulers.mainThread()) <span class="comment">// 指定主线程</span></div><div class="line">    .observeOn(AndroidSchedulers.mainThread())</div><div class="line">    .subscribe(subscriber);</div></pre></td></tr></table></figure>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/07/28/Rxjava入门/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">page 1 of 1</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2016 Vincent. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <h4 id="about-card-name">Vincent</h4>
        
            <h5 id="about-card-bio"><p>author.bio</p>
</h5>
        
        
            <h5 id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </h5>
        
        
    </div>
</div>

        <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-close"></i></span>
            <a href="https://algolia.com" target="_blank" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    autofocus="autofocus"/>
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">no post found</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://yoursite.com/2016/07/28/Rxjava入门/">
                            <h3 class="media-heading">Rxjava学习总结</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jul 28, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="no post found"
                data-message-one="1 post found"
                data-message-other="{n} posts found">
                1 post found
            </p>
        </div>
    </div>
</div>
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-taaobz4ueybn54ikf9gtu3wlm8tpgzjkwfknygrtitquljbwokv26p56moto.min.js"></script>
<!--SCRIPTS END-->



    </body>
</html>
